### 汇编初体验

通过`g++ a.cpp -S --std=c++11 masm=intel`生成.s文件。

 * 由于g++编译出的汇编代码时AT&T风格的（贝尔实验室），操作的源和目的数与intel风格的操作顺序相反，使用-masm=intel转换为intel风格。

```asm
;常用指令：
mov rax rbp	;将rbp寄存器的值拷贝到rax寄存器
lea rax rbp	;不解析源寄存器，将rbp寄存器的地址拷贝到rax
mov eax 0 	;eax寄存器一般存放函数返回值
```

* 函数执行过程中所占用的栈空间叫做栈帧，通过ebp基址指针（又叫帧指针）指向栈底，esp栈指针指向栈顶，在64位系统中叫做rbp，rsp。函数调用时层层嵌套的因此栈帧也是嵌套的，每次压栈时esp向下生长。当调用其他函数时，将返回地址，函数参数压栈，然后`mov ebp esp`，将esp值赋值给ebp建立新的栈帧；然后跳转到函数位置，执行函数；函数执行后依次弹栈，回到调用前的位置（返回地址）。

```asm
func:
	push ebp
	mov ebp esp
	;执行函数体
	mov eax rax	;rax的值作为函数返回值
	pop ebp		;恢复之前的栈帧
	ret
```

### 指针与引用

* 引用的底层是通过指针来实现的，相当于指针常量`T* const`，可以改变指向对象但不能改变指针的朝向 ，这对应引用定义时必须初始化，途中不能引用其他对象的语法。每当出现引用，编译器会在栈区分配一块指针内存，用来存储引用对象的地址。（因此引用不占内存是错误的）。

```asm
	int i = 1;
00007FF6FB5852DB  mov         dword ptr [i],1  
	int& ir = i;			;引用的汇编和使用指针是一样的，int* ir = &i;
00007FF6FB5852E2  lea         rax,[i]  			;将i地址放到rax
00007FF6FB5852E6  mov         qword ptr [ir],rax ;将i地址赋值给ir
```

* 编译器对两种操作进行翻译

  * 对引用取地址：不能得到引用的存储位置，而是得到被引用对象的地址。
  * sizeof引用得到被引用对象的大小，而sizeof指针得到的是指针大小。

* 引用与指针的区别

  * 引用在定义时必须初始化，而且在途中不能再引用其他对象。指针在定义时可初始化也可不初始化，未初始化的指针成为野指针，造成非法访问。引用时对象别名，意义更加明确。

* 注意事项

  ```cpp
  //类似于智能指针，如果使用引用来操作对象，就不要用指针在来操作对象，否则存在 对已释放内存解引用的风险
  int* i = new int;
  int& ref = *i;
  delete i;
  ref = 10;		//对已释放内存解引用
  ```

  

  